{
  "name": "Go9",
  "tagline": "golang arry as function parameters  ",
  "body": "`golang中的指针需要注意点:`\r\n\r\n1.gonglang中的数组和c中的指针的区别比较大:\r\n====\r\n    在golang中数组名不在是数组的首地址了,如下列子很明显:\r\n    \r\n```golang    \r\nfunc use_array(args [5]int){\r\n    args[1] = 100;\r\n}\r\n\r\nfunc main() {\r\n    var args = [5]int{1, 2, 3, 4, 5};\r\n    use_array(args);\r\n    fmt.Println(args);\r\n}\r\n```   \r\n最终还是输出: 1 2 3 4 5 \r\n\r\n所以在这里得使用指针:\r\n\r\n```golang  \r\nfunc use_array(args *[5]int){\r\n    args[1] = 100;\r\n}\r\n\r\nfunc main() {\r\n    var args = [5]int{1, 2, 3, 4, 5};\r\n    use_array(&args);\r\n    fmt.Println(args);\r\n}\r\n```     \r\n这样才可以的，这点在和c语言比起来差别还是蛮大的．   \r\n\r\n\r\n2.还有个小的区别就是在结构体指针中：\r\n====\r\n```golang \r\ntype Point struct{\r\n    x int;\r\n    y int;\r\n}\r\n\r\nfunc main() {\r\n    var p *Point;\r\n    p = new(Point);\r\n    p.x = 1;\r\n    p.y = 2;\r\n\r\n    fmt.Printf(\"%p\\n\", p); // 地址\r\n\r\n    fmt.Printf(\"%p\\n\", &(p.x));\r\n}\r\n```\r\n\r\n其实和c语言的区别就是在访问结构体指针成员变量的时候不使用->了．\r\n\r\n3.golang中函数调用参数全部是传值的,包括 slice/map/chan 在内所有类型,而非传引用:\r\n=====\r\n\r\n```golang  \r\nfunc main() {\r\n        a := []int{1, 2, 3}\r\n        fmt.Println(a)\r\n        modifySlice(a)\r\n        fmt.Println(a)\r\n}\r\nfunc modifySlice(data []int) {\r\n\r\n        data = nil\r\n}\r\n```\r\n\r\n[1,2,3]\r\n[1,2,3]\r\n\r\n```golang  \r\nfunc main() {\r\n        var arrgs = [5]int{1, 2, 3, 4, 5}; \r\n\r\n        a := []int{1, 2, 3}\r\n        fmt.Printf(\"arry   %p\\n\", arrgs)\r\n        fmt.Printf(\"arry   %p\\n\", &arrgs)\r\n        fmt.Printf(\"arry %p\\n\", &arrgs[0])\r\n        fmt.Printf(\"%p\\n\", a)\r\n        fmt.Printf(\"%p\\n\", &a) \r\n        fmt.Printf(\"%p\\n\", &a[0])\r\n        fmt.Println(a)\r\n        modifySliceData(a)\r\n        fmt.Println(a)\r\n}\r\n\r\nfunc modifySliceData(data []int) {\r\n        data[0] = 0 \r\n}\r\n```  \r\n\r\n```  \r\narry   %!p([5]int=[1 2 3 4 5])\r\narry   0xc20803a180\r\narry 0xc20803a180\r\n0xc20801e040\r\n0xc20801e020\r\n0xc20801e040\r\n[1 2 3]\r\n[0 2 3]\r\n```       \r\n注意slice和数组的区别，以及data = nil 和　data[0] = 0的不同效果．  \r\n\r\n\r\n４.闭包是传递引用的：\r\n=====\r\n\r\n```golang\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n        for i := 0; i < 5; i++ {\r\n                defer fmt.Printf(\"%d \", i) // Output: 4 3 2 1 0\r\n        }\r\n        fmt.Printf(\"\\n\")\r\n        for i := 0; i < 5; i++ {\r\n                defer func() { fmt.Printf(\"%d \", i) }() // Output: 5 5 5 5 5\r\n        }\r\n}\r\n```\r\n\r\n5 5 5 5 5 4 3 2 1 0    \r\n\r\n\r\n注意下面效果：   \r\n\r\n```golang\r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n        for i := 0; i < 5; i++ {\r\n                defer fmt.Printf(\"%d \", i) // Output: 4 3 2 1 0\r\n        }\r\n        fmt.Printf(\"\\n\")\r\n        for i := 0; i < 5; i++ {\r\n                defer func(i int) { fmt.Printf(\"%d \", i) }(i) // Output: 5 5 5 5 5\r\n        }\r\n}\r\n```\r\n \r\n4 3 2 1 0 4 3 2 1 0     \r\n\r\n```golang  \r\npackage main\r\n\r\nimport \"fmt\"\r\n\r\nfunc main() {\r\n        for i := 0; i < 5; i++ {\r\n                defer fmt.Printf(\"%d \", i) // Output: 4 3 2 1 0\r\n        }\r\n        fmt.Printf(\"\\n\")\r\n        for i := 0; i < 5; i++ {\r\n                i := i\r\n                defer func() { fmt.Printf(\"%d \", i) }() // Output: 5 5 5 5 5\r\n        }\r\n}\r\n```   \r\n4 3 2 1 0 4 3 2 1 0    \r\n\r\n即使用了临时变量改变了传引用．　     \r\n\r\n\r\nCommunite  \r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}